# 基于应用属性的 PrivateKey 加密方案说明

## 方案概述

本方案采用**基于应用属性的密钥派生**方式，使用 `appId` 通过 PBKDF2 算法自动派生加密密钥，**无需额外管理加密密钥**。

## 核心优势 ✨

### 1. 无需管理额外密钥 🎯
- ❌ 不需要配置 `encryption-key`
- ❌ 不需要担心密钥文件丢失
- ❌ 不需要环境变量配置
- ✅ 只要 `appId` 不变，就能随时解密

### 2. 密钥轮换简单 🔄
- 如果需要更换 privateKey：
  1. 使用 SQL 生成工具生成新的 privateKey 和加密值
  2. 更新数据库即可
- 不存在"旧密钥无法解密旧数据"的问题

### 3. 高安全性 🔒
- **算法**：PBKDF2-HMAC-SHA256（NIST 推荐标准）
- **迭代次数**：65536 次（防暴力破解）
- **密钥长度**：256 位
- **加密算法**：AES-256-GCM（带认证标签）

### 4. 零配置 ⚙️
- 应用层无需任何配置
- 自动从数据库读取 appId
- 自动派生密钥并解密

## 工作原理

### 加密流程

```
1. 输入: appId=10001, privateKey="64位Hex..."
   ↓
2. 密钥派生: PBKDF2(password="10001", salt="FIXED", iterations=65536)
   ↓
3. 得到派生密钥: derivedKey (256位)
   ↓
4. AES-256-GCM 加密: encrypt(privateKey, derivedKey)
   ↓
5. 存入数据库: encryptedPrivateKey
```

### 解密流程

```
1. 从数据库读取: appId=10001, encryptedPrivateKey
   ↓
2. 密钥派生: PBKDF2(password="10001", salt="FIXED", iterations=65536)
   ↓
3. 得到相同的派生密钥: derivedKey (与加密时完全相同)
   ↓
4. AES-256-GCM 解密: decrypt(encryptedPrivateKey, derivedKey)
   ↓
5. 得到原始值: privateKey="64位Hex..."
```

## 使用方法

### 方式一：使用 SQL 生成工具（推荐）

#### 1. 运行工具

```bash
cd /Users/by/2026/im/im-server/common
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.AppSqlGenerator"
```

#### 2. 按提示输入信息

```
请输入应用ID (输入 'q' 退出): 10001
请输入应用名称: IM测试应用

✓ 生成成功！
┌────────────────────────────────────────────────────────┐
│ 应用ID: 10001
│ 应用名称: IM测试应用
│ 明文 PrivateKey: a1b2c3d4... (请妥善保管)
│ 加密后: Dy8hJ3k2Qw5Lx9Vm...
└────────────────────────────────────────────────────────┘
```

#### 3. 复制 SQL 并执行

工具会自动生成完整的 SQL 插入语句，直接复制执行即可。

### 方式二：使用代码加密

```java
import com.pd.im.common.util.EncryptionUtil;

public class Example {
    public static void main(String[] args) {
        Integer appId = 10001;
        String privateKey = "a1b2..."; // 64位 Hex

        // 加密
        String encrypted = EncryptionUtil.encryptWithApp(privateKey, appId);
        System.out.println("加密后: " + encrypted);

        // 解密
        String decrypted = EncryptionUtil.decryptWithApp(encrypted, appId);
        System.out.println("解密后: " + decrypted);
    }
}
```

## 数据库操作

### 插入新应用

```sql
-- 1. 使用 AppSqlGenerator 工具生成加密后的 privateKey 和 SQL
-- 2. 执行插入语句

INSERT INTO `im_app` (
    `app_id`, `app_name`, `private_key`,
    `app_status`, `create_time`
) VALUES (
    10001,
    'IM测试应用',
    'Dy8hJ3k2Qw5Lx9Vm...',  -- 使用工具生成的加密值
    1,
    UNIX_TIMESTAMP() * 1000
);
```

### 更新应用 privateKey

```sql
-- 1. 使用工具生成新的 privateKey 和加密值
-- 2. 执行更新语句

UPDATE `im_app`
SET `private_key` = 'NEW_ENCRYPTED_VALUE'
WHERE `app_id` = 10001;
```

## 重要注意事项 ⚠️

### 1. 固定盐值不要修改

```java
// 位于 EncryptionUtil.java
private static final String FIXED_SALT = "IM_APP_PRIVATE_KEY_SALT_2025";
// ⚠️ 修改此值后，所有已加密的数据将无法解密
```

### 2. 迭代次数不要修改

```java
// 位于 EncryptionUtil.java
private static final int PBKDF2_ITERATIONS = 65536;
// ⚠️ 修改此值后，所有已加密的数据将无法解密
```

## 系统自动解密

应用层代码无需任何改动，`ImAppServiceImpl` 会自动处理：

```java
@Override
public String getPrivateKey(Integer appId) {
    ImAppEntity app = getAppById(appId);
    // ... 状态校验 ...

    // 自动使用 appId 解密
    return EncryptionUtil.decryptWithApp(
        app.getPrivateKey(),
        appId
    );
}
```

## 与外部密钥方案对比

| 特性 | 基于应用属性（推荐）| 外部加密密钥 |
|------|------------------|-------------|
| **需要配置** | ❌ 不需要 | ✅ 需要配置 encryption-key |
| **密钥管理** | ❌ 无需管理 | ✅ 需要管理和备份 |
| **密钥丢失风险** | ❌ 无风险（appId在数据库中）| ✅ 高风险（密钥丢失无法恢复）|
| **密钥轮换** | ✅ 简单（重新加密即可）| ⚠️ 复杂（需要解密所有旧数据）|
| **安全性** | ✅ 高（PBKDF2 + AES-256-GCM）| ✅ 高（AES-256-GCM）|
| **环境迁移** | ✅ 容易（只需数据库）| ⚠️ 麻烦（需要同步密钥）|

## 安全性说明

### 1. 数据库泄露
- **风险**：攻击者获得了 appId 和加密的 privateKey
- **防护**：攻击者仍需破解 PBKDF2（65536次迭代），计算成本极高
- **建议**：保护好数据库访问权限

### 2. 固定盐值的安全性
- **说明**：虽然使用固定盐值，但 PBKDF2 的高迭代次数保证了安全性
- **对比**：
  - 不同应用使用不同的 appId
  - 相当于每个应用有独立的"密码"
  - 攻击者需要对每个应用单独破解

## 常见问题

### Q1: 为什么不用动态盐值？
**A**: 动态盐值需要存储，增加了复杂度。固定盐值配合 PBKDF2 的高迭代次数已经提供了足够的安全性。

### Q2: 如何生成新的 privateKey？
**A**: 推荐使用 `AppSqlGenerator` 工具，它会自动生成 64 位 Hex 格式的安全 privateKey 并完成加密。

### Q3: 性能如何？
**A**:
- PBKDF2 首次派生密钥需要约 50-100ms
- 但有 Spring Cache 缓存，后续访问无性能损耗
- 实际业务中影响可忽略不计

## 总结

**推荐使用基于应用属性的加密方案，因为：**

✅ **零配置** - 无需管理额外密钥
✅ **零风险** - 不存在密钥丢失问题
✅ **零维护** - 自动派生和解密
✅ **高安全** - PBKDF2 + AES-256-GCM
✅ **易迁移** - 只需要数据库数据

---

**文档版本：** 2.1
**更新时间：** 2025-12-26
**作者：** Claude & Parker

## 核心优势 ✨

### 1. 无需管理额外密钥 🎯
- ❌ 不需要配置 `encryption-key`
- ❌ 不需要担心密钥文件丢失
- ❌ 不需要环境变量配置
- ✅ 只要 `appId` 和 `appKey` 不变，就能随时解密

### 2. 密钥轮换简单 🔄
- 如果需要更换 privateKey：
  1. 使用新的 privateKey 重新加密
  2. 使用相同的 appId 和 appKey
  3. 更新数据库即可
- 不存在"旧密钥无法解密旧数据"的问题

### 3. 高安全性 🔒
- **算法**：PBKDF2-HMAC-SHA256（NIST 推荐标准）
- **迭代次数**：65536 次（防暴力破解）
- **密钥长度**：256 位
- **加密算法**：AES-256-GCM（带认证标签）

### 4. 零配置 ⚙️
- 应用层无需任何配置
- 自动从数据库读取 appId 和 appKey
- 自动派生密钥并解密

## 工作原理

### 加密流程

```
1. 输入: appId=10001, appKey="im_test_app_key", privateKey="123456"
   ↓
2. 密钥派生: PBKDF2(password="10001:im_test_app_key", salt="FIXED", iterations=65536)
   ↓
3. 得到派生密钥: derivedKey (256位)
   ↓
4. AES-256-GCM 加密: encrypt(privateKey, derivedKey)
   ↓
5. 存入数据库: encryptedPrivateKey
```

### 解密流程

```
1. 从数据库读取: appId=10001, appKey="im_test_app_key", encryptedPrivateKey
   ↓
2. 密钥派生: PBKDF2(password="10001:im_test_app_key", salt="FIXED", iterations=65536)
   ↓
3. 得到相同的派生密钥: derivedKey (与加密时完全相同)
   ↓
4. AES-256-GCM 解密: decrypt(encryptedPrivateKey, derivedKey)
   ↓
5. 得到原始值: privateKey="123456"
```

## 使用方法

### 方式一：使用加密工具（推荐）

#### 1. 运行加密工具

```bash
cd /Users/by/2026/im/im-server
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.AppPrivateKeyEncryptor"
```

#### 2. 按提示输入信息

```
请输入应用ID (输入 'q' 退出): 10001
请输入应用Key (app_key): im_test_app_key
请输入要加密的 privateKey: 123456

✓ 加密成功！
┌────────────────────────────────────────────────────────┐
│ 应用ID: 10001
│ 应用Key: im_test_app_key
│ 原始 privateKey: 123456
│ 加密后: Dy8hJ3k2Qw5Lx9Vm...
└────────────────────────────────────────────────────────┘
```

#### 3. 复制 SQL 并执行

工具会自动生成完整的 SQL 插入语句，直接复制执行即可。

### 方式二：使用代码加密

```java
import com.pd.im.common.util.EncryptionUtil;

public class Example {
    public static void main(String[] args) {
        Integer appId = 10001;
        String appKey = "im_test_app_key";
        String privateKey = "123456";

        // 加密
        String encrypted = EncryptionUtil.encryptWithApp(privateKey, appId, appKey);
        System.out.println("加密后: " + encrypted);

        // 解密
        String decrypted = EncryptionUtil.decryptWithApp(encrypted, appId, appKey);
        System.out.println("解密后: " + decrypted);
    }
}
```

## 数据库操作

### 插入新应用

```sql
-- 1. 使用工具生成加密后的 privateKey
-- 2. 执行插入语句

INSERT INTO `im_app` (
    `app_id`, `app_name`, `app_key`, `private_key`,
    `owner_id`, `app_status`, `create_time`
) VALUES (
    10001,
    'IM测试应用',
    'im_test_app_key',
    'Dy8hJ3k2Qw5Lx9Vm...',  -- 使用工具生成的加密值
    'admin',
    1,
    UNIX_TIMESTAMP() * 1000
);
```

### 更新应用 privateKey

```sql
-- 1. 使用工具加密新的 privateKey（使用相同的 appId 和 appKey）
-- 2. 执行更新语句

UPDATE `im_app`
SET `private_key` = 'NEW_ENCRYPTED_VALUE'  -- 新的加密值
WHERE `app_id` = 10001;
```

## 重要注意事项 ⚠️

### 1. 不要修改 appKey

```sql
-- ❌ 错误：修改 appKey 会导致无法解密 privateKey
UPDATE `im_app` SET `app_key` = 'new_key' WHERE `app_id` = 10001;

-- ✅ 正确：如果确实需要修改 appKey
-- 1. 使用旧的 appId 和 appKey 解密 privateKey
-- 2. 使用新的 appId 和 appKey 重新加密 privateKey
-- 3. 更新 appKey 和 encrypted privateKey
```

### 2. 固定盐值不要修改

```java
// 位于 EncryptionUtil.java
private static final String FIXED_SALT = "IM_APP_PRIVATE_KEY_SALT_2025";
// ⚠️ 修改此值后，所有已加密的数据将无法解密
```

### 3. 迭代次数不要修改

```java
// 位于 EncryptionUtil.java
private static final int PBKDF2_ITERATIONS = 65536;
// ⚠️ 修改此值后，所有已加密的数据将无法解密
```

## 系统自动解密

应用层代码无需任何改动，`ImAppServiceImpl` 会自动处理：

```java
@Override
public String getPrivateKey(Integer appId) {
    ImAppEntity app = getAppById(appId);
    // ... 状态校验 ...

    // 自动使用 appId 和 appKey 解密
    return EncryptionUtil.decryptWithApp(
        app.getPrivateKey(),
        appId,
        app.getAppKey()
    );
}
```

## 与外部密钥方案对比

| 特性 | 基于应用属性（推荐）| 外部加密密钥 |
|------|------------------|-------------|
| **需要配置** | ❌ 不需要 | ✅ 需要配置 encryption-key |
| **密钥管理** | ❌ 无需管理 | ✅ 需要管理和备份 |
| **密钥丢失风险** | ❌ 无风险（appId和appKey在数据库中）| ✅ 高风险（密钥丢失无法恢复）|
| **密钥轮换** | ✅ 简单（重新加密即可）| ⚠️ 复杂（需要解密所有旧数据）|
| **安全性** | ✅ 高（PBKDF2 + AES-256-GCM）| ✅ 高（AES-256-GCM）|
| **环境迁移** | ✅ 容易（只需数据库）| ⚠️ 麻烦（需要同步密钥）|

## 安全性说明

### 攻击场景分析

#### 1. 数据库泄露
- **风险**：攻击者获得了 appId、appKey 和加密的 privateKey
- **防护**：攻击者仍需破解 PBKDF2（65536次迭代），计算成本极高
- **建议**：保护好数据库访问权限

#### 2. appKey 泄露
- **风险**：如果 appKey 泄露，攻击者可能解密 privateKey
- **防护**：
  - appKey 不要在日志中输出
  - 定期审计 appKey 访问
  - 使用强度高的 appKey（长度、复杂度）
- **建议**：appKey 应该像密码一样保护

#### 3. 固定盐值的安全性
- **说明**：虽然使用固定盐值，但 PBKDF2 的高迭代次数保证了安全性
- **对比**：
  - 不同应用使用不同的 appId 和 appKey
  - 相当于每个应用有独立的"密码"
  - 攻击者需要对每个应用单独破解

## 常见问题

### Q1: 为什么不用动态盐值？
**A**: 动态盐值需要存储，增加了复杂度。固定盐值配合 PBKDF2 的高迭代次数已经提供了足够的安全性。

### Q2: appKey 被修改了怎么办？
**A**: 需要重新加密 privateKey：
```java
// 1. 使用旧 appKey 解密
String privateKey = EncryptionUtil.decryptWithApp(encrypted, appId, oldAppKey);

// 2. 使用新 appKey 重新加密
String newEncrypted = EncryptionUtil.encryptWithApp(privateKey, appId, newAppKey);

// 3. 更新数据库
```

### Q3: 如何迁移现有的明文 privateKey？
**A**: 使用 AppPrivateKeyEncryptor 工具批量加密：
```bash
# 运行工具，依次输入每个应用的信息
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.AppPrivateKeyEncryptor"
```

### Q4: 性能如何？
**A**:
- PBKDF2 首次派生密钥需要约 50-100ms
- 但有 Spring Cache 缓存，后续访问无性能损耗
- 实际业务中影响可忽略不计

## 总结

**推荐使用基于应用属性的加密方案，因为：**

✅ **零配置** - 无需管理额外密钥
✅ **零风险** - 不存在密钥丢失问题
✅ **零维护** - 自动派生和解密
✅ **高安全** - PBKDF2 + AES-256-GCM
✅ **易迁移** - 只需要数据库数据

唯一需要注意的是：**不要随意修改应用的 appKey**

---

**文档版本：** 2.0
**更新时间：** 2025-12-24
**作者：** Claude & Parker
