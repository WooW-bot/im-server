# IM 应用配置管理设计说明

## 概述

将应用配置（如 `privateKey`）从硬编码的 `AppConfig` 迁移到数据库管理，实现多租户应用隔离和灵活的配置管理。

## 数据库设计

### 1. im_app（应用基本信息表）

存储应用的核心配置信息：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| app_id | INT | 应用ID（自增主键）|
| app_name | VARCHAR(100) | 应用名称 |
| **private_key** | VARCHAR(500) | **UserSig签名私钥(已加密)** |
| app_status | TINYINT | 应用状态：0-已停用 1-正常 2-已锁定 |
| callback_url | VARCHAR(500) | 回调地址 |
| max_user_count | INT | 最大用户数限制 |
| max_group_count | INT | 最大群组数限制 |
| expire_time | BIGINT | 过期时间（毫秒时间戳）|
| create_time | BIGINT | 创建时间 |
| update_time | BIGINT | 更新时间 |

**索引设计：**
- PRIMARY KEY: `app_id`
- KEY: `app_status`

### 2. im_app_config（应用配置表）

灵活存储各类配置项：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| config_id | BIGINT | 配置ID（自增主键）|
| app_id | INT | 应用ID |
| config_key | VARCHAR(100) | 配置键 |
| config_value | TEXT | 配置值 |
| config_type | VARCHAR(50) | 配置类型：string, int, boolean, json |
| description | VARCHAR(500) | 配置描述 |
| is_encrypted | TINYINT | 是否加密：0-否 1-是 |
| create_time | BIGINT | 创建时间 |
| update_time | BIGINT | 更新时间 |

**索引设计：**
- PRIMARY KEY: `config_id`
- UNIQUE KEY: `(app_id, config_key)`

**配置示例：**
- `msg_recall_time_limit`: 消息撤回时间限制（秒）
- `enable_message_read_receipt`: 是否启用消息已读回执
- `max_group_member_count`: 单个群组最大成员数
- `sensitive_words`: 敏感词列表（JSON）

### 3. im_app_audit_log（应用操作日志表）

记录应用配置的所有变更：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| log_id | BIGINT | 日志ID（自增主键）|
| app_id | INT | 应用ID |
| operator_id | VARCHAR(50) | 操作人ID |
| operator_ip | VARCHAR(50) | 操作人IP |
| action_type | VARCHAR(50) | 操作类型：create, update, delete, config_change |
| action_desc | VARCHAR(500) | 操作描述 |
| old_value | TEXT | 修改前的值（JSON）|
| new_value | TEXT | 修改后的值（JSON）|
| create_time | BIGINT | 创建时间 |

**索引设计：**
- PRIMARY KEY: `log_id`
- KEY: `app_id`, `operator_id`, `create_time`

## 代码实现

### 1. 实体类

**ImAppEntity**
```java
@Data
@TableName("im_app")
public class ImAppEntity {
    @TableId(type = IdType.AUTO)
    private Integer appId;
    private String appName;
    private String privateKey;  // 关键字段（加密存储）
    private Integer appStatus;
    // ... 其他字段
}
```

### 2. Service层

**ImAppService**
```java
public interface ImAppService {
    // 根据应用ID获取应用信息
    ImAppEntity getAppById(Integer appId);

    // 根据应用ID获取私钥（核心方法，会自动解密）
    String getPrivateKey(Integer appId);

    // 验证应用是否有效
    boolean isAppValid(Integer appId);
}
```

**ImAppServiceImpl**
- 使用 `@Cacheable` 注解缓存应用信息和私钥，提高性能
- 在 `getPrivateKey` 方法中进行多重校验：
  - 应用是否存在
  - 应用状态是否正常（app_status = 1）
  - 应用是否过期（expire_time）
- 自动调用 `EncryptionUtil.decryptWithApp` 进行解密

### 3. IdentityCheck 改造

```java
private final ImAppService imAppService;

// 从数据库获取应用私钥
String privateKey = imAppService.getPrivateKey(Integer.parseInt(appId));
if (StringUtils.isBlank(privateKey)) {
    log.error("Failed to get private key for appId={}", appId);
    return GatewayErrorCode.USERSIGN_IS_ERROR;
}
```

## 优势分析

### 1. 架构优势
- ✅ **多租户支持**：每个应用独立配置，互不影响
- ✅ **动态配置**：无需重启服务即可修改配置
- ✅ **集中管理**：所有应用配置统一管理，便于运维

### 2. 安全性提升
- ✅ **隔离性**：不同应用使用不同的私钥，提高安全性
- ✅ **权限控制**：可基于应用状态控制访问权限
- ✅ **审计追踪**：所有配置变更都有日志记录

### 3. 使用便捷
- ✅ **自动化工具**：提供 `AppSqlGenerator` 自动生成配置 SQL

## 使用示例

### 1. 初始化应用

**推荐使用 `AppSqlGenerator` 工具生成 SQL。**

手动 SQL 示例：
```sql
INSERT INTO `im_app` (`app_name`, `private_key`, `app_status`, `create_time`)
VALUES ('测试应用', 'ENCRYPTED_PRIVATE_KEY', 1, UNIX_TIMESTAMP() * 1000);
```

### 2. 添加应用配置

```sql
INSERT INTO `im_app_config` (`app_id`, `config_key`, `config_value`, `config_type`, `description`, `create_time`)
VALUES (10001, 'msg_recall_time_limit', '120', 'int', '消息撤回时间限制（秒）', UNIX_TIMESTAMP() * 1000);
```

### 3. 停用应用

```sql
UPDATE `im_app` SET `app_status` = 0 WHERE `app_id` = 10001;
```

## 安全增强：privateKey 加密存储

### 1. 加密方案

使用 **AES-256-GCM** 加密算法对数据库中的 privateKey 进行加密存储，密钥由 `appId` 派生。

### 2. 使用方法

#### Step 1: 运行生成工具

```bash
cd /Users/by/2026/im/im-server/common
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.AppSqlGenerator"
```

#### Step 2: 按提示操作

输入 `appId` 和 `appName`，工具会自动生成明文 privateKey 和 SQL 语句。

#### Step 3: 执行 SQL

将生成的 SQL 语句执行到数据库。

### 3. 代码实现

**ImAppServiceImpl.getPrivateKey()**

```java
@Override
public String getPrivateKey(Integer appId) {
    ImAppEntity app = getAppById(appId);

    // ... 状态校验 ...

    // 自动使用 appId 解密
    return EncryptionUtil.decryptWithApp(
        app.getPrivateKey(),
        appId
    );
}
```

## 文件清单

### SQL 文件
- `/assert/sql/im_app_management.sql` - 应用管理相关表结构

### Java 文件
- `/service/src/main/java/com/pd/im/service/app/dao/ImAppEntity.java` - 应用实体类
- `/service/src/main/java/com/pd/im/service/app/service/ImAppServiceImpl.java` - Service 实现
- `/common/src/main/java/com/pd/im/common/tools/AppSqlGenerator.java` - SQL 生成工具

### 文档
- `/assert/doc/应用配置管理设计说明.md` - 本文档
- `/assert/doc/基于应用属性的加密方案说明.md` - 加密方案详细说明

---

**创建时间：** 2025-12-24
**更新时间：** 2025-12-26
**作者：** Claude & Parker
**版本：** 2.1

## 数据库设计

### 1. im_app（应用基本信息表）

存储应用的核心配置信息：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| app_id | INT | 应用ID（自增主键）|
| app_name | VARCHAR(100) | 应用名称 |
| app_key | VARCHAR(100) | 应用标识（唯一）|
| **private_key** | VARCHAR(500) | **UserSig签名私钥** |
| owner_id | VARCHAR(50) | 应用所有者用户ID |
| owner_name | VARCHAR(100) | 应用所有者名称 |
| app_status | TINYINT | 应用状态：0-已停用 1-正常 2-已锁定 |
| callback_url | VARCHAR(500) | 回调地址 |
| max_user_count | INT | 最大用户数限制 |
| max_group_count | INT | 最大群组数限制 |
| expire_time | BIGINT | 过期时间（毫秒时间戳）|
| create_time | BIGINT | 创建时间 |
| update_time | BIGINT | 更新时间 |

**索引设计：**
- PRIMARY KEY: `app_id`
- UNIQUE KEY: `app_key`
- KEY: `owner_id`, `app_status`

### 2. im_app_config（应用配置表）

灵活存储各类配置项：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| config_id | BIGINT | 配置ID（自增主键）|
| app_id | INT | 应用ID |
| config_key | VARCHAR(100) | 配置键 |
| config_value | TEXT | 配置值 |
| config_type | VARCHAR(50) | 配置类型：string, int, boolean, json |
| description | VARCHAR(500) | 配置描述 |
| is_encrypted | TINYINT | 是否加密：0-否 1-是 |
| create_time | BIGINT | 创建时间 |
| update_time | BIGINT | 更新时间 |

**索引设计：**
- PRIMARY KEY: `config_id`
- UNIQUE KEY: `(app_id, config_key)`

**配置示例：**
- `msg_recall_time_limit`: 消息撤回时间限制（秒）
- `enable_message_read_receipt`: 是否启用消息已读回执
- `max_group_member_count`: 单个群组最大成员数
- `sensitive_words`: 敏感词列表（JSON）

### 3. im_app_audit_log（应用操作日志表）

记录应用配置的所有变更：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| log_id | BIGINT | 日志ID（自增主键）|
| app_id | INT | 应用ID |
| operator_id | VARCHAR(50) | 操作人ID |
| operator_ip | VARCHAR(50) | 操作人IP |
| action_type | VARCHAR(50) | 操作类型：create, update, delete, config_change |
| action_desc | VARCHAR(500) | 操作描述 |
| old_value | TEXT | 修改前的值（JSON）|
| new_value | TEXT | 修改后的值（JSON）|
| create_time | BIGINT | 创建时间 |

**索引设计：**
- PRIMARY KEY: `log_id`
- KEY: `app_id`, `operator_id`, `create_time`

## 代码实现

### 1. 实体类

**ImAppEntity**
```java
@Data
@TableName("im_app")
public class ImAppEntity {
    @TableId(type = IdType.AUTO)
    private Integer appId;
    private String appName;
    private String appKey;
    private String privateKey;  // 关键字段
    private Integer appStatus;
    // ... 其他字段
}
```

### 2. DAO层

**ImAppMapper**
```java
@Mapper
public interface ImAppMapper extends BaseMapper<ImAppEntity> {
}
```

### 3. Service层

**ImAppService**
```java
public interface ImAppService {
    // 根据应用ID获取应用信息
    ImAppEntity getAppById(Integer appId);

    // 根据应用ID获取私钥（核心方法）
    String getPrivateKey(Integer appId);

    // 根据应用Key获取应用信息
    ImAppEntity getAppByKey(String appKey);

    // 验证应用是否有效
    boolean isAppValid(Integer appId);
}
```

**ImAppServiceImpl**
- 使用 `@Cacheable` 注解缓存应用信息和私钥，提高性能
- 在 `getPrivateKey` 方法中进行多重校验：
  - 应用是否存在
  - 应用状态是否正常（app_status = 1）
  - 应用是否过期（expire_time）

### 4. IdentityCheck 改造

**改造前：**
```java
@Autowired
AppConfig appConfig;

String privateKey = appConfig.getPrivateKey();
```

**改造后：**
```java
private final ImAppService imAppService;

// 从数据库获取应用私钥
String privateKey = imAppService.getPrivateKey(Integer.parseInt(appId));
if (StringUtils.isBlank(privateKey)) {
    log.error("Failed to get private key for appId={}", appId);
    return GatewayErrorCode.USERSIGN_IS_ERROR;
}
```

## 优势分析

### 1. 架构优势
- ✅ **多租户支持**：每个应用独立配置，互不影响
- ✅ **动态配置**：无需重启服务即可修改配置
- ✅ **集中管理**：所有应用配置统一管理，便于运维

### 2. 安全性提升
- ✅ **隔离性**：不同应用使用不同的私钥，提高安全性
- ✅ **权限控制**：可基于应用状态控制访问权限
- ✅ **审计追踪**：所有配置变更都有日志记录

### 3. 扩展性
- ✅ **灵活配置**：通过 `im_app_config` 表支持任意配置项
- ✅ **应用管理**：支持应用的启用/停用/锁定等生命周期管理
- ✅ **限流控制**：可配置用户数、群组数等限制

### 4. 性能优化
- ✅ **缓存机制**：使用 Spring Cache 缓存应用信息
- ✅ **减少配置读取**：一次查询，多次使用

## 使用示例

### 1. 初始化应用

```sql
INSERT INTO `im_app` (`app_name`, `app_key`, `private_key`, `owner_id`, `app_status`, `create_time`)
VALUES ('测试应用', 'test_app_key', 'your_private_key_here', 'admin', 1, UNIX_TIMESTAMP() * 1000);
```

### 2. 添加应用配置

```sql
INSERT INTO `im_app_config` (`app_id`, `config_key`, `config_value`, `config_type`, `description`, `create_time`)
VALUES (10001, 'msg_recall_time_limit', '120', 'int', '消息撤回时间限制（秒）', UNIX_TIMESTAMP() * 1000);
```

### 3. 停用应用

```sql
UPDATE `im_app` SET `app_status` = 0 WHERE `app_id` = 10001;
```

停用后，该应用的所有请求将无法通过签名验证。

## 后续规划

### 短期规划
1. ✅ 完成数据库表设计
2. ✅ 完成基础代码实现
3. ⏳ 创建应用管理后台页面
4. ⏳ 实现应用配置的增删改查接口

### 中期规划
1. 实现配置热更新机制
2. 添加配置变更通知功能
3. 实现应用使用情况统计
4. 添加应用配额管理

### 长期规划
1. 支持应用级别的权限控制
2. 实现配置模板功能
3. 支持配置版本管理和回滚
4. 实现多环境配置管理（开发/测试/生产）

## 安全增强：privateKey 加密存储

### 1. 加密方案

使用 **AES-256-GCM** 加密算法对数据库中的 privateKey 进行加密存储：

- **算法**：AES-256-GCM（高安全性，带认证）
- **密钥长度**：256 位
- **IV 长度**：12 字节（随机生成）
- **加密工具**：`EncryptionUtil` 类

### 2. 实现流程

```
存储流程：
原始 privateKey → AES-256-GCM 加密 → Base64 编码 → 存入数据库

读取流程：
数据库读取 → Base64 解码 → AES-256-GCM 解密 → 原始 privateKey
```

### 3. 使用方法

#### Step 1: 生成加密密钥

```bash
# 运行工具类生成密钥
cd /Users/by/2026/im/im-server/common
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.PrivateKeyEncryptor"
```

或在 IDE 中运行 `PrivateKeyEncryptor.main()`

#### Step 2: 配置加密密钥

在 `application.properties` 中添加：

```properties
# 开发环境
appconfig.encryption-key=rJ8F5Kx2Qw9Yz7Vb3Nm6Lp1Rt4Hg8Cj0Ds5Af2Wq1Ex6Tv3Zy9==

# 生产环境（使用环境变量）
appconfig.encryption-key=${APPCONFIG_ENCRYPTION_KEY}
```

#### Step 3: 加密 privateKey

使用 `PrivateKeyEncryptor` 工具：

```
是否需要生成新的加密密钥？(y/n): y
✓ 生成的加密密钥（请妥善保管）: xxx

请输入要加密的 privateKey (输入 'q' 退出): 123456
✓ 加密成功！
  原始值: 123456
  加密后: nEo5tQmWvXqKjRaIbPuDgFhL3cM7yT8zN2wS6xV4kA==MTIzNDU2
```

#### Step 4: 更新数据库

```sql
INSERT INTO `im_app` (`app_id`, `app_name`, `private_key`, ...)
VALUES (10001, '测试应用', 'nEo5tQmWvXqKjRaIbPuDgFhL3cM7yT8zN2wS6xV4kA==MTIzNDU2', ...);
```

### 4. 代码实现

**ImAppServiceImpl.getPrivateKey()**

```java
@Override
public String getPrivateKey(Integer appId) {
    ImAppEntity app = getAppById(appId);

    // ... 状态校验 ...

    // 解密私钥
    String encryptedPrivateKey = app.getPrivateKey();
    String encryptionKey = appConfig.getEncryptionKey();

    return EncryptionUtil.decrypt(encryptedPrivateKey, encryptionKey);
}
```

### 5. 安全建议

- ✅ **生产环境重新生成密钥**：不使用文档中的示例密钥
- ✅ **使用环境变量**：避免密钥硬编码在配置文件中
- ✅ **定期轮换密钥**：建议每季度或半年更换加密密钥
- ✅ **备份密钥**：密钥丢失将导致无法解密数据
- ✅ **使用 KMS**：生产环境建议使用云密钥管理服务

## 注意事项

1. **数据迁移**：现有系统迁移时，需要将 `AppConfig` 中的配置导入到数据库
2. **缓存失效**：修改配置后需要清除对应的缓存
3. **安全性**：✅ 已实现 privateKey 加密存储（AES-256-GCM）
4. **兼容性**：保留 `AppConfig` 作为兜底方案，避免数据库故障时服务不可用
5. **加密密钥管理**：妥善保管加密密钥，建议使用环境变量或 KMS

## 文件清单

### SQL 文件
- `/assert/sql/im_app_management.sql` - 应用管理相关表结构（含加密说明）

### Java 文件

**核心业务代码**
- `/service/src/main/java/com/pd/im/service/app/dao/ImAppEntity.java` - 应用实体类
- `/service/src/main/java/com/pd/im/service/app/dao/mapper/ImAppMapper.java` - Mapper 接口
- `/service/src/main/java/com/pd/im/service/app/service/ImAppService.java` - Service 接口
- `/service/src/main/java/com/pd/im/service/app/service/impl/ImAppServiceImpl.java` - Service 实现（含解密逻辑）
- `/service/src/main/java/com/pd/im/service/interceptor/IdentityCheck.java` - 身份验证（已改用数据库配置）

**加密工具类**
- `/common/src/main/java/com/pd/im/common/util/EncryptionUtil.java` - AES-256-GCM 加密解密工具
- `/common/src/main/java/com/pd/im/common/tools/PrivateKeyEncryptor.java` - PrivateKey 加密工具（交互式）
- `/common/src/main/java/com/pd/im/common/config/AppConfig.java` - 配置类（已添加 encryptionKey）

### 配置文件
- `/assert/config/application-encryption-example.properties` - 加密配置示例

### 文档
- `/assert/doc/应用配置管理设计说明.md` - 本文档
- `/assert/doc/密钥生成工具使用说明.md` - 密钥生成和管理详细说明

## 快速开始

### 1. 创建数据库表

```bash
mysql -u root -p im_core < /Users/by/2026/im/im-server/assert/sql/im_app_management.sql
```

### 2. 生成并配置加密密钥

```bash
# 运行工具生成密钥
mvn exec:java -Dexec.mainClass="com.pd.im.common.tools.PrivateKeyEncryptor"

# 将生成的密钥添加到配置文件
echo "appconfig.encryption-key=你生成的密钥" >> application.properties
```

### 3. 加密并插入应用数据

使用 `PrivateKeyEncryptor` 工具加密 privateKey，然后执行 SQL 插入。

### 4. 启动服务

```bash
mvn spring-boot:run
```

系统会自动从数据库读取加密的 privateKey 并解密使用。

---

**创建时间：** 2025-12-24
**作者：** Claude & Parker
**版本：** 2.0（新增加密存储功能）
